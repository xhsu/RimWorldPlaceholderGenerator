// RimWorldPlaceholderGenerator.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "Precompiled.hpp"
#include "Mod.hpp"

import Application;
import CommandLine;
import Style;

using namespace std::literals;

namespace fs = std::filesystem;

using std::array;
using std::pair;
using std::span;
using std::string;
using std::string_view;
using std::tuple;
using std::vector;

inline constexpr array g_rgszAutoCompleteLanguages =
{
	"Catalan"sv,
	"ChineseSimplified"sv,
	"ChineseTraditional"sv,
	"Czech"sv,
	"Danish"sv,
	"Dutch"sv,
	"Estonian"sv,
	"Finnish"sv,
	"French"sv,
	"German"sv,
	"Greek"sv,
	"Hungarian"sv,
	"Italian"sv,
	"Japanese"sv,
	"Korean"sv,
	"Norwegian"sv,
	"Polish"sv,
	"Portuguese"sv,
	"PortugueseBrazilian"sv,
	"Romanian"sv,
	"Russian"sv,
	"Slovak"sv,
	"Spanish"sv,
	"SpanishLatin"sv,
	"Swedish"sv,
	"Turkish"sv,
	"Ukrainian"sv,
};


static void ShowVersion(span<string_view const> args) noexcept
{
	fmt::println("\nApp version: {}", APP_VERSION.ToString());
	fmt::println("Compile at: " __DATE__);

	if (!args.empty())
		fmt::println("\tVersion as uint32: {}", APP_VERSION.AsInt32());

	fmt::println("");
}

static void Default(const char* path_to_mod, string_view target_lang) noexcept
{
	GetModClasses(path_to_mod, &gModClasses);
	gAllNamespaces.insert_range(gModClasses | std::views::values | std::views::transform(&class_info_t::m_Namespace));

	Path::Resolve(path_to_mod, target_lang);
	ProcessMod();
}

static void NoXRef(span<string_view const> args) noexcept
{
	auto& path_to_mod = args[0];
	auto& target_lang = args[1];

	GetModClasses(path_to_mod.data(), &gModClasses);
	gAllNamespaces.insert_range(gModClasses | std::views::values | std::views::transform(&class_info_t::m_Namespace));

	Path::Resolve(path_to_mod, target_lang);
	NoXRef();
}

static void ClrDbg(span<string_view const> args) noexcept
{
	auto& path_to_mod = args[0];
	auto& target_lang = args[1];

	Path::Resolve(path_to_mod, target_lang);
	Path::ClearDebugFiles();
}

#pragma region Command line stuff
inline constexpr string_view ARG_DESC_HELP[] = { "-help" };
inline constexpr string_view ARG_DESC_VERSION[] = { "-version", "[bool:show_extra]", };
inline constexpr string_view ARG_DESC_CLRDBG[] = { "-clrdbg", "mod_dir", "target_lang", };
inline constexpr string_view ARG_DESC_NOXREF[] = { "-noxref", "mod_dir", "target_lang", };

extern void ShowHelp(span<string_view const>) noexcept;

// #UPDATE_AT_CPP26 span over initializer list
inline constexpr tuple<span<string_view const>, void(*)(span<string_view const>), string_view> CMD_HANDLER[] =
{
	{ ARG_DESC_HELP, &ShowHelp, "Show all commands of this application." },
	{ ARG_DESC_VERSION, &ShowVersion, "Display version of this application." },
	{ ARG_DESC_CLRDBG, &ClrDbg, "Clearing all files generated by this application under debug mode." },
	{ ARG_DESC_NOXREF, &NoXRef, "Finding all localization files which has no reference from current mod." },
};

void ShowHelp(span<string_view const>) noexcept
{
	fmt::print(Style::Info, "\n");

	constexpr auto max_len = std::ranges::max(
		CMD_HANDLER
		| std::views::elements<0>
		| std::views::transform(&span<string_view const>::front)
		| std::views::transform(&string_view::length)
	);

	for (auto&& [arg_desc, pfn, desc] : CMD_HANDLER)
	{
		fmt::print(Style::Action, "{}\n", desc);
		fmt::print(Style::Name, "\t{}", arg_desc[0]);
		fmt::print(Style::Info, "{}", string(max_len - arg_desc[0].length(), ' '));

		for (auto&& arg : arg_desc | std::views::drop(1))
			fmt::print(arg[0] == '[' ? Style::Skipping : Style::Info, " {}", arg);

		fmt::print(Style::Info, "\n\n");
	}
}

static_assert(
	// Compile-time sanity check - make our life easier.
	[]() consteval -> bool
	{
		for (auto&& arg_desc : CMD_HANDLER | std::views::elements<0>)
		{
			if (!CommandLineArgSanity(arg_desc))
				return false;
		}

		return true;
	}()
);
#pragma endregion Command line stuff

void fn()
{
	constexpr char const* arr[] =
	{
		"location/app.exe",
		"arg1",
		"arg2",
		"-dir",
		"Test/1.3",
		"-lang",
		"English",
		"ChineseTraditional",
		"-noxref",
		"-clrdbg",
	};


}

int main(int argc, char *argv[]) noexcept
{
	CommandLineUnitTest();

	auto const args =
		std::span(argv, (size_t)argc)
		| as_string_view
		| std::ranges::to<vector>();

	for (auto&& v :
		args
		| std::views::drop(1)	// the first one is always the path to this application.
		| std::views::chunk_by(+[](string_view const& lhs, string_view const& rhs) noexcept { return rhs[0] != '-'; }))
	{
		if (v.empty() || v.front().empty())
			continue;

		for (auto&& [arg_desc, pfn, desc] : CMD_HANDLER)
			if (CommandLineWrapper(desc, arg_desc, v, pfn))
				break;
	}

	switch (argc)
	{
	case 1:
		fmt::print("No folder selected.\nHint: Drag and drop mod folder on this console app.\n");
		while (std::cin.get() != '\n') {}
		return EXIT_SUCCESS;

	case 2:
	{
		if (_stricmp(argv[1], "-version") == 0)
		{
			fmt::println("App version: {}", APP_VERSION.ToString());
			fmt::println("Compile at: {}", __DATE__);
			fmt::println("");

			return EXIT_SUCCESS;
		}

		fmt::print(Style::Info, "Selected mod path: {}\n", argv[1]);
		fmt::print("Input target language.\n");

		auto sz = ""s;

		for (char c = std::cin.get(); c != '\n'; c = std::cin.get())
			sz.push_back(c);

		if (sz.empty())
			return EXIT_SUCCESS;

		for (auto &&lang : g_rgszAutoCompleteLanguages)
		{
			if (_strnicmp(lang.data(), sz.c_str(),
				std::min(lang.size(), sz.size())) == 0)
			{
				sz = lang;
				break;
			}
		}

		fmt::print("Selected language: {}\n\n", sz);
#ifndef _DEBUG
		std::this_thread::sleep_for(1s);
#endif
		Default(argv[1], sz);

#ifndef _DEBUG
		fmt::print(Style::Positive, "\nDONE.\nPress Enter to exit.");
		while (std::cin.get() != '\n') {}
#endif
		return EXIT_SUCCESS;
	}

	case 3:
		fmt::print(Style::Info, "Selected mod path: {}\n", argv[1]);
		fmt::print(Style::Info, "Selected language: {}\n\n", argv[2]);
#ifndef _DEBUG
		std::this_thread::sleep_for(1s);
#endif
		Default(argv[1], argv[2]);

#ifndef _DEBUG
		fmt::print(Style::Positive, "\nDONE.\nPress Enter to exit.");
		while (std::cin.get() != '\n') {}
#endif
		return EXIT_SUCCESS;

	case 4:
	{
		string_view const szCommand{ argv[3] };

		if (szCommand == "-noxref")
		{
			//NoXRef(argv[1], argv[2]);
		}
		if (szCommand == "-clrdbg")
		{
			Path::Resolve(argv[1], argv[2]);
			Path::ClearDebugFiles();
		}
		else
		{
			fmt::print(Style::Error, "Unknown command: \"{}\"", szCommand);
		}

		return EXIT_SUCCESS;
	}
	default:
		fmt::print("Too many arguments.\nExpected: 1, 2 or 3, but {} received.\n", argc - 1);
		while (std::cin.get() != '\n') {}
		return EXIT_SUCCESS;
	}

	return EXIT_SUCCESS;
}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
